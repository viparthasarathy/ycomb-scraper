<!DOCTYPE html>
<html>
  <head>
    <title>James Long</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="alternate" type="application/atom+xml" href="http://feeds.feedburner.com/jlongster" title="Atom Feed" />
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/css/highlight/tomorrow-night.css" />
    <link rel="stylesheet" type="text/css" href="/output/styles.css" />

    <script type="text/javascript" src="//use.typekit.net/eeq3shn.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
  </head>
  <body>
    <div id="mount"><div data-reactid=".mawesuy5ts" data-react-checksum="974840882"><div class="" data-reactid=".mawesuy5ts.0"></div><div data-reactid=".mawesuy5ts.1"><header data-reactid=".mawesuy5ts.1.0"><div class="titlebar" data-reactid=".mawesuy5ts.1.0.0"><a href="/" class="" data-reactid=".mawesuy5ts.1.0.0.0">The Blog of James Long</a></div></header><main data-reactid=".mawesuy5ts.1.1"><div class="extra" data-reactid=".mawesuy5ts.1.1.0"><ul data-reactid=".mawesuy5ts.1.1.0.0"><li data-reactid=".mawesuy5ts.1.1.0.0.0"><a href="https://twitter.com/jlongster" data-reactid=".mawesuy5ts.1.1.0.0.0.0">twitter</a></li><li data-reactid=".mawesuy5ts.1.1.0.0.1"><a href="https://github.com/jlongster/" data-reactid=".mawesuy5ts.1.1.0.0.1.0">github</a></li><li data-reactid=".mawesuy5ts.1.1.0.0.2"><a href="http://feeds.feedburner.com/jlongster" data-reactid=".mawesuy5ts.1.1.0.0.2.0">rss</a></li></ul></div><div class="main-wrapper clearfix" data-reactid=".mawesuy5ts.1.1.1"><noscript data-reactid=".mawesuy5ts.1.1.1.0"></noscript><noscript data-reactid=".mawesuy5ts.1.1.1.1:0"></noscript><noscript data-reactid=".mawesuy5ts.1.1.1.1:1"></noscript><noscript data-reactid=".mawesuy5ts.1.1.1.1:2"></noscript><article class="clearfix" data-reactid=".mawesuy5ts.1.1.1.1:3"><div class="intro-img" data-reactid=".mawesuy5ts.1.1.1.1:3.0"><img src="http://jlongster.com/s/posts/react-native.png" data-reactid=".mawesuy5ts.1.1.1.1:3.0.0"></div><h1 data-reactid=".mawesuy5ts.1.1.1.1:3.1">First Impressions using React Native</h1><div class="date" data-reactid=".mawesuy5ts.1.1.1.1:3.2">February 06 2015</div><div data-reactid=".mawesuy5ts.1.1.1.1:3.3"><p>Facebook gave all attendees of <a href="http://conf.reactjs.com/">React Conf</a> early access to the source code of <a href="https://www.youtube.com/watch?v=KVZ-P-ZI6W4">React Native</a>, a new way to write native mobile apps. The technology takes everything that's great about React.js and applies it to native apps. You write JavaScript components using a set of builtin primitives that are backed by actual native iOS or Android components.</p>

<p>First off, I know it sucks it's not completely public yet. Facebook isn't yet fully open-source, so it takes time to move projects into an open light. They are working on removing code specific to their environment and setting up a process to receive contributions. I think it's great they strive to be more open, and they care deeply about the React community. The project will be fully open-sourced soon.</p>

<p>I don't find anything fundamentally wrong with the slow release. I'm happy to discuss it with you if do. But let's <strong>please</strong> leave that for another discussion.</p>

<p>Because if you decide to get distracted by it, you might miss <em>a huge shift</em> in how we write native apps. The best part about this shift is that it's more like web apps.</p>

<p>I developed iOS apps for a few years, so I have experience with native development. After using React Native, I can only explain it like this:</p>

<p><img src="http://jlongster.com/s/posts/jawdrop.png" alt="" title="" /></p>

<p>We've all heard the promise of cross-platform native apps driven by JavaScript. <a href="http://www.appcelerator.com/">Titanium</a>, <a href="http://phonegap.com/">PhoneGap</a>, and other projects allow various levels of hooking in with the native environment. All of them fall short. Either you're just wrapping a web app in a web view, or they try to mimick HTML &amp; CSS which is hard to build apps with. With the latter, you're also interfacing directly with native objects <em>all the time</em>, which is doomed to fail performance-wise. React Native actually performs the layout on a separate thread, so the main thread is as free as it can possibly be to focus on smooth animations (it also provides <a href="http://css-tricks.com/snippets/css/a-guide-to-flexbox/">flexbox</a> for layout, which something that <strike>no other framework provides</strike> few other frameworks provide (ionic <a href="http://learn.ionicframework.com/formulas/using-the-grid/">does</a>, which is cool!)).</p>

<p>It only takes a few minutes playing with React Native to realize the potential it has. This <em>works</em>. It feels like I'm developing for the web. But I'm writing a real native app, and you <em>seriously</em> can't tell the difference. At the UI level, there is no difference; these are all native UIViews beautifully sliding around like normal.</p>

<p>This is <em>solid</em> engineering. And it completely reinforces the fact that <strong>React.js is the right way to build apps</strong>. I can write a native app <em>using the same techniques</em> as I would write web app. Let's start treating the DOM as an implementation detail, just like UIViews.</p>

<p>I love the web. But if we don't take a step and take a critical look at what's wrong, we might miss out on something big. The web is fundamentally weird to build apps on: the mess of HTML and CSS get <em>in the way</em> of frameworks instead of helping them. Perhaps React Native will finally drive this point home. I look forward to seeing how it will push the web to become a better platform for apps. Instead of thinking of it as moving away from the web, think of it as a prototype for a different direction of the web.</p>

<p>Are you feeling giddy yet?! I'll tell you how React Native works! You can learn more the videos from React Conf <a href="https://www.youtube.com/watch?v=KVZ-P-ZI6W4">here</a> and <a href="https://www.youtube.com/watch?v=7rDsRXj9-cU">here</a>.</p>

<p>React Native uses JavaScriptCore in iOS to run JavaScript (Android and other platforms will be supported in the future). The important part is that it runs JavaScript on a separate thread (other frameworks like Titanium do as well). You write your components in JavaScript just like you would with React.js, except instead of using <code>div</code> and <code>a</code> you use things like <code>View</code> and <code>Text</code>. You get all the benefits of React's composability for building UIs (which, safe to say, is <strong>awesome</strong>). And remember, JavaScript is not just a language but a platform, and there is large number of wonderful compile-to-JS languages to pick from.</p>

<p>React Native takes your UI and sends the minimal amount of data to the main thread to render it with native components. A <code>View</code> is a <code>UIView</code>, for example. The best part is, you don't have to worry about updating your UI; you declaratively render your UI based on some state, and React uses a diffing algorithm to send the smallest amount of changes necessary over the bridge.</p>

<p>Writing native UIs has never been easier, and additionally there is <em>no</em> performance impact on things like animations because JS is running on a separate thread. Smooth as butta.</p>

<h2>An OpenGL App with React Native</h2>

<p>My first React Native app is a non-traditional one: I wrote a 3d Wavefront obj model viewer. I've always been interested in game development, but I hated writing native UIs. React Native just gave me the web for game UIs.</p>

<p>I'm sure you'll see a lot of traditional app demos with native navigation and animation and all that. I thought it would be cool to show that it's just as easy to throw React Native on top of an OpenGL view.</p>

<p>All you have to do to integrate React Native is create an <code>RCTRootView</code> in your controller, tell it where your JS lives, and add it to the window. In my case, I first create an OpenGL view, and I add the <code>RCTRootView</code> as a subview on top of it. Integration was painless.</p>

<p><img src="http://jlongster.com/s/posts/react-native-demo.gif" alt="" title="" /></p>

<p>You can press Cmd+R to instantly refresh the UI and pick up any changes you made. Only the <code>RCTRootView</code> will update, so I can easily build out and refresh my UI without having to reload the OpenGL layer!</p>

<p>Here's an example component, <code>ObjList</code>, that lists available files and loads a mesh when an item is clicked. This uses a <code>ListView</code> which is a native scroll view that only renders the rows within view, like any native app does. Using it here is much simpler though.</p>

<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ObjList = React.createClass({
  <span class="hljs-comment">// a few methods clipped....</span>

  selectModel: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(file)</span> </span>{
    controller.loadMesh(file);
  },

  renderRow: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(file)</span> </span>{
    <span class="hljs-keyword">return</span> View(
      <span class="hljs-literal">null</span>,
      TouchableHighlight(
        { onPress: () =&gt; <span class="hljs-keyword">this</span>.selectModel(file),
          underlayColor: <span class="hljs-string">'rgba(0, 0, 0, .6)'</span> },
        Text({ style: { height: <span class="hljs-number">30</span>, color: <span class="hljs-string">'white'</span> }}, file)
      )
    );
  },

  render: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> source = <span class="hljs-keyword">this</span>.getDataSource(<span class="hljs-keyword">this</span>.props.files);

    <span class="hljs-keyword">return</span> ListView({
      style: { flex: <span class="hljs-number">1</span> },
      renderRow: <span class="hljs-keyword">this</span>.renderRow,
      dataSource: source
    });
  }
});
</code></pre>

<p>In my <code>App</code> component I have a <code>handleSearch</code> method that fires when the text input changes. I just change the state, which rerenders the app and the <code>ObjList</code> component with the new state, showing only the new list of files.</p>

<pre><code class="javascript hljs">handleSearch: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> </span>{
  <span class="hljs-keyword">var</span> text = e.nativeEvent.text;
  <span class="hljs-keyword">var</span> files = allFiles.filter(x =&gt; x.indexOf(text.toLowerCase()) !== -<span class="hljs-number">1</span>);
  <span class="hljs-keyword">this</span>.setState({ files: files });
}
</code></pre>

<p>Notice the <code>controller.loadMesh()</code> call in the <code>ObjList</code> component. That is an Objective-C method that I've marked as exported, and the bridge will pick it up and make it available the JS. Working with the bridge was pretty easy, and it will only get better from here. Here's the implementation of <code>loadMesh</code>:</p>

<pre><code class="c hljs">- (void)loadMesh:(NSString *)path {
    RCT_EXPORT();

    dispatch_async(dispatch_get_main_queue(), ^{
        teapotNode_.material.diffuse = [self randomColor];
        teapotNode_.wavefrontMeshA = [REMeshCache meshNamed:path];
        [self reset];
    });
}
</code></pre>

<p><code>RCT_EXPORT()</code> marks it as a method to export (there's a little more work to actually instantiate the class somewhere else). These methods are invoked on a separate thread, but I need to load the mesh on the main thread (since it will load data into OpenGL), so I queue a block of code to be run on the main thread.</p>

<p>Here's a video going through it more detail:</p>

<iframe width="700" height="394" src="https://www.youtube.com/embed/OPFf53fdUmQ" frameborder="0" allowfullscreen></iframe>

<p>The ability to declaratively construct my UI as components and respond to events by simply changing state is powerful. React.js has proven that. Suddenly, we get to do the <em>exact</em> same thing for native apps. "Learn once, write anywhere" as the React devs say. Also see: <a href="https://medium.com/@ericflo/facebook-just-taught-us-all-how-to-build-websites-51f1e7e996f2">Facebook just taught us all how to build websites</a>.</p></div><div class="tags" data-reactid=".mawesuy5ts.1.1.1.1:3.4"><a href="/tag/react" data-reactid=".mawesuy5ts.1.1.1.1:3.4.0">react</a></div><div class="social" data-reactid=".mawesuy5ts.1.1.1.1:3.5"><div class="social-buttons" data-reactid=".mawesuy5ts.1.1.1.1:3.5.0"><div>
  <a href="https://twitter.com/share" class="twitter-share-button" data-via="jlongster">Tweet</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</div>

<div>
  <div class="fb-like" data-send="false" data-layout="button_count" data-width="70" data-show-faces="false" data-font="verdana"></div>

  <div id="fb-root"></div>
  <script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=203253883025618";
    fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>
</div>

<div>
  <a href="http://news.ycombinator.com/submit" class="hn-share-button" {% if post.hnurl %}data-url="{{ post.hnurl }}"{% endif %}>Vote on HN</a>
  <script>
    (function(d, t) {
    var g = d.createElement(t),
    s = d.getElementsByTagName(t)[0];
    g.src = '//hnbutton.appspot.com/static/hn.js';
    s.parentNode.insertBefore(g, s);
    }(document, 'script'));
  </script>
</div>
</div></div></article></div></main><footer data-reactid=".mawesuy5ts.1.2"><div class="footer-wrapper" data-reactid=".mawesuy5ts.1.2.0"><div data-reactid=".mawesuy5ts.1.2.0.0"><div class="readnext" data-reactid=".mawesuy5ts.1.2.0.0.0"><h3 data-reactid=".mawesuy5ts.1.2.0.0.0.0">Read Next</h3><a href="/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome" data-reactid=".mawesuy5ts.1.2.0.0.0.1"><h1 data-reactid=".mawesuy5ts.1.2.0.0.0.1.0">Removing User Interface Complexity, or Why React is Awesome</h1></a><p data-reactid=".mawesuy5ts.1.2.0.0.0.2">I've been studying frameworks and libraries like Ember, Angular, and React the past several months, and given Web Components a lot of thought. I found React to be the most enlightening, and I'll explain why.</p></div><div data-reactid=".mawesuy5ts.1.2.0.0.1"><div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'jlongster';
  var disqus_url = window.location.href.split('?')[0];

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div></div><div class="footer-text" data-reactid=".mawesuy5ts.1.2.0.1"><p data-reactid=".mawesuy5ts.1.2.0.1.0"><span data-reactid=".mawesuy5ts.1.2.0.1.0.0">Made by James Long, a devtools developer for </span><a href="http://mozilla.org" data-reactid=".mawesuy5ts.1.2.0.1.0.1">Mozilla</a><span data-reactid=".mawesuy5ts.1.2.0.1.0.2">. Feel free to </span><a href="mailto:longster@gmail.com" data-reactid=".mawesuy5ts.1.2.0.1.0.3">get in touch</a><span data-reactid=".mawesuy5ts.1.2.0.1.0.4"> with me.</span></p><p data-reactid=".mawesuy5ts.1.2.0.1.1">© James Long 2012-2015</p></div></div></footer></div></div></div>
    <script id="payload" type="application/payload">{"data":{"post":{"post":{"content":"Facebook gave all attendees of [React Conf](http://conf.reactjs.com/) early access to the source code of [React Native](https://www.youtube.com/watch?v=KVZ-P-ZI6W4), a new way to write native mobile apps. The technology takes everything that's great about React.js and applies it to native apps. You write JavaScript components using a set of builtin primitives that are backed by actual native iOS or Android components.\n\nFirst off, I know it sucks it's not completely public yet. Facebook isn't yet fully open-source, so it takes time to move projects into an open light. They are working on removing code specific to their environment and setting up a process to receive contributions. I think it's great they strive to be more open, and they care deeply about the React community. The project will be fully open-sourced soon.\n\nI don't find anything fundamentally wrong with the slow release. I'm happy to discuss it with you if do. But let's **please** leave that for another discussion.\n\nBecause if you decide to get distracted by it, you might miss *a huge shift* in how we write native apps. The best part about this shift is that it's more like web apps.\n\nI developed iOS apps for a few years, so I have experience with native development. After using React Native, I can only explain it like this:\n\n![](http://jlongster.com/s/posts/jawdrop.png)\n\nWe've all heard the promise of cross-platform native apps driven by JavaScript. [Titanium](http://www.appcelerator.com/), [PhoneGap](http://phonegap.com/), and other projects allow various levels of hooking in with the native environment. All of them fall short. Either you're just wrapping a web app in a web view, or they try to mimick HTML &amp; CSS which is hard to build apps with. With the latter, you're also interfacing directly with native objects *all the time*, which is doomed to fail performance-wise. React Native actually performs the layout on a separate thread, so the main thread is as free as it can possibly be to focus on smooth animations (it also provides [flexbox](http://css-tricks.com/snippets/css/a-guide-to-flexbox/) for layout, which something that &lt;strike&gt;no other framework provides&lt;/strike&gt; few other frameworks provide (ionic [does](http://learn.ionicframework.com/formulas/using-the-grid/), which is cool!)).\n\nIt only takes a few minutes playing with React Native to realize the potential it has. This *works*. It feels like I'm developing for the web. But I'm writing a real native app, and you *seriously* can't tell the difference. At the UI level, there is no difference; these are all native UIViews beautifully sliding around like normal.\n\nThis is *solid* engineering. And it completely reinforces the fact that **React.js is the right way to build apps**. I can write a native app *using the same techniques* as I would write web app. Let's start treating the DOM as an implementation detail, just like UIViews.\n\nI love the web. But if we don't take a step and take a critical look at what's wrong, we might miss out on something big. The web is fundamentally weird to build apps on: the mess of HTML and CSS get *in the way* of frameworks instead of helping them. Perhaps React Native will finally drive this point home. I look forward to seeing how it will push the web to become a better platform for apps. Instead of thinking of it as moving away from the web, think of it as a prototype for a different direction of the web.\n\nAre you feeling giddy yet?! I'll tell you how React Native works! You can learn more the videos from React Conf [here](https://www.youtube.com/watch?v=KVZ-P-ZI6W4) and [here](https://www.youtube.com/watch?v=7rDsRXj9-cU).\n\nReact Native uses JavaScriptCore in iOS to run JavaScript (Android and other platforms will be supported in the future). The important part is that it runs JavaScript on a separate thread (other frameworks like Titanium do as well). You write your components in JavaScript just like you would with React.js, except instead of using `div` and `a` you use things like `View` and `Text`. You get all the benefits of React's composability for building UIs (which, safe to say, is **awesome**). And remember, JavaScript is not just a language but a platform, and there is large number of wonderful compile-to-JS languages to pick from.\n\nReact Native takes your UI and sends the minimal amount of data to the main thread to render it with native components. A `View` is a `UIView`, for example. The best part is, you don't have to worry about updating your UI; you declaratively render your UI based on some state, and React uses a diffing algorithm to send the smallest amount of changes necessary over the bridge.\n\nWriting native UIs has never been easier, and additionally there is *no* performance impact on things like animations because JS is running on a separate thread. Smooth as butta.\n\n## An OpenGL App with React Native\n\nMy first React Native app is a non-traditional one: I wrote a 3d Wavefront obj model viewer. I've always been interested in game development, but I hated writing native UIs. React Native just gave me the web for game UIs.\n\nI'm sure you'll see a lot of traditional app demos with native navigation and animation and all that. I thought it would be cool to show that it's just as easy to throw React Native on top of an OpenGL view.\n\nAll you have to do to integrate React Native is create an `RCTRootView` in your controller, tell it where your JS lives, and add it to the window. In my case, I first create an OpenGL view, and I add the `RCTRootView` as a subview on top of it. Integration was painless.\n\n![](http://jlongster.com/s/posts/react-native-demo.gif)\n\nYou can press Cmd+R to instantly refresh the UI and pick up any changes you made. Only the `RCTRootView` will update, so I can easily build out and refresh my UI without having to reload the OpenGL layer!\n\nHere's an example component, `ObjList`, that lists available files and loads a mesh when an item is clicked. This uses a `ListView` which is a native scroll view that only renders the rows within view, like any native app does. Using it here is much simpler though.\n\n```js\nvar ObjList = React.createClass({\n  // a few methods clipped....\n\n  selectModel: function(file) {\n    controller.loadMesh(file);\n  },\n\n  renderRow: function(file) {\n    return View(\n      null,\n      TouchableHighlight(\n        { onPress: () =&gt; this.selectModel(file),\n          underlayColor: 'rgba(0, 0, 0, .6)' },\n        Text({ style: { height: 30, color: 'white' }}, file)\n      )\n    );\n  },\n\n  render: function() {\n    var source = this.getDataSource(this.props.files);\n\n    return ListView({\n      style: { flex: 1 },\n      renderRow: this.renderRow,\n      dataSource: source\n    });\n  }\n});\n```\n\nIn my `App` component I have a `handleSearch` method that fires when the text input changes. I just change the state, which rerenders the app and the `ObjList` component with the new state, showing only the new list of files.\n\n```js\nhandleSearch: function(e) {\n  var text = e.nativeEvent.text;\n  var files = allFiles.filter(x =&gt; x.indexOf(text.toLowerCase()) !== -1);\n  this.setState({ files: files });\n}\n```\n\nNotice the `controller.loadMesh()` call in the `ObjList` component. That is an Objective-C method that I've marked as exported, and the bridge will pick it up and make it available the JS. Working with the bridge was pretty easy, and it will only get better from here. Here's the implementation of `loadMesh`:\n\n```c\n- (void)loadMesh:(NSString *)path {\n    RCT_EXPORT();\n\n    dispatch_async(dispatch_get_main_queue(), ^{\n        teapotNode_.material.diffuse = [self randomColor];\n        teapotNode_.wavefrontMeshA = [REMeshCache meshNamed:path];\n        [self reset];\n    });\n}\n```\n\n`RCT_EXPORT()` marks it as a method to export (there's a little more work to actually instantiate the class somewhere else). These methods are invoked on a separate thread, but I need to load the mesh on the main thread (since it will load data into OpenGL), so I queue a block of code to be run on the main thread.\n\nHere's a video going through it more detail:\n\n&lt;iframe width=\"700\" height=\"394\" src=\"https://www.youtube.com/embed/OPFf53fdUmQ\" frameborder=\"0\" allowfullscreen&gt;&lt;/iframe&gt;\n\nThe ability to declaratively construct my UI as components and respond to events by simply changing state is powerful. React.js has proven that. Suddenly, we get to do the *exact* same thing for native apps. \"Learn once, write anywhere\" as the React devs say. Also see: [Facebook just taught us all how to build websites](https://medium.com/@ericflo/facebook-just-taught-us-all-how-to-build-websites-51f1e7e996f2).\n\n\n\n","tags":["react"],"headerimg":"http://jlongster.com/s/posts/react-native.png","date":20150206,"shorturl":"First-Impressions-using-React-Native","readnext":"Removing-User-Interface-Complexity,-or-Why-React-is-Awesome","abstract":"React Native is a new way to build native apps, using all the same technology you learned with React.js. It's amazing. In this article I give a demo of my first app built with it and explain the experience.","published":true,"title":"First Impressions using React Native"},"readnext":{"updatedDate":"20140514","published":true,"tags":["ui","react"],"headerimg":"","title":"Removing User Interface Complexity, or Why React is Awesome","content":"I've been studying frameworks and libraries like Ember, Angular, and React the past several months, and given Web Components a lot of thought. These all solve similar problems to varying degrees, and are in conflict in some ways and in harmony in others.\n\nI'm mostly concerned with the core problems of data binding and componentizing UIs. After much research and usage of the technologies mentioned above, I found [React](http://facebook.github.io/react/) to provide the best solution.\n\nI ask that you set aside your framework prejudices and read this post with an open mind. This post is not to evangelize React specifically, but to explain why its technique is profound. I want developers steeped in other technologies to take a hard look at these techniques, particularly those involved in Web Components.\n\nThis post actually started as a call to address problems with Web Components. But I've come to realize a few things: the bottom half of the Web Components effort (unlocking all the builtin stuff so that even native tags could be rewritten) is a great thing, Web Components are a step up from current technology regardless, and I don't want to do harm to that effort. My concerns are quite vague as well, so it doesn't make a good blog post. I can't reconcile what I want components to be with Web Components, and it's much better if I fully explain what I think is the best solution and leave it up to the readers to apply if they choose.\n\n&lt;a id=\"breakpoint-initial\"&gt;&lt;/a&gt;\n\n## The Bloop Library\n\nI'm not going to focus on React specifically. In fact, just in case it would be distracting, we're not going to use React at all.\n\nWe're going to build our own library from scratch that is highly inspired by React. This lets us play with all kinds of ideas with a very small amount of code. This is prototype-quality, of course, and wouldn't scale to large UIs, but using something like React would make it scale.\n\nLet's call our library **Bloop**. Our library should let us change data and transparently keep the UI in sync. It should allow us to structure the UI into components, and flow data between them sanely.\n\nFirst, we need a way to represent behavior and structure. It's easy to write behaviors as JavaScript, but what about the structure? We could use a templating language that looks like HTML, but it's much easier just to represent it in JavaScript too. It keeps the component together, makes it trivial to wire up the structure with behaviors, and allows us to easily share the component. Just imagine being able to use JavaScript for importing a component:\n\n```js\nvar MyToolbar = require('shared-components/toolbar');\n```\n\nYou can't even do something as basic as that with Web Components.\n\nThis is what a component looks like with our library. It shows a number and a button that, when pressed, increments the number. `getInitialState` returns the initial state of the object that can be accessed with `this.state`.\n\n&lt;a id=\"breakpoint-app1\"&gt;&lt;/a&gt;\n\n```js\nvar Box = Bloop.createClass({\n  getInitialState: function() {\n    return { number: 0 };\n  },\n  \n  updateNumber: function() {\n    this.state.number++;\n  },\n  \n  render: function() {\n    return dom.div(\n      this.state.number,\n      dom.button({ onClick: this.updateNumber }, 'Increment')\n    );\n  }\n});\n```\n\nNext, we need a way to render it into the page. You can use `renderComponent` to render a component instance into a DOM element.\n\n```js\nBloop.renderComponent(Box(), document.body);\n```\n\nThere's a problem with this though: it doesn't rerender whenever the state changes. The `Box` component mutates its state directly, so we don't know when something has changed. We could add a `set` method that tells us what is changing, but then we need to figure out which pieces of the DOM to update, which gets really complicated. Here's an idea: rerender the entire app whenever a change is made. That way, it's really easy to keep everything in sync.\n\nBut how do we know when a change is made? A `set` method to change state could trigger a rerender, but there's an even easier way to react to changes: continuously call `renderComponent` with `requestAnimationFrame` to repaint the UI, and only change the DOM when the component returns different content. **React does not do this** by default; it has a `setState` method to change state that triggeres a repaint. Let's just have some fun with `requestAnimationFrame`, even though you would never do this in production. View the full source code for this example [here](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-a-increment-js).\n\n```js\nvar box = Box();\n\nfunction render() {\n  Bloop.renderComponent(box, document.body);\n  requestAnimationFrame(render);\n}\n\nrender();\n```\n\nRerendering everything (and only applying it to the DOM when something actually changed) vastly simplifies the architecture of our app. Observables+DOM elements is a leaky abstraction, and as a user I shouldn't need an intimate knowledge of how the UI is kept in sync with my data. This architecture opens up lots of various ways to optimize the rendering, but it's all completely transparent to the user.\n\nThe Bloop library is only [250 lines of JavaScript](https://gist.github.com/jlongster/11192270), and simply renders a component by setting `innerHTML` if changed. Since you usually have a top-level `App` component, that means the entire app is rendered with `innerHTML`. I told you it was prototype-quality, right? In a twisted, absurd way, it's shocking how far you can go with this. And the kicker is you can easily swap this out with React to get much better rendering performance, since React has a virtual DOM and will only touch the real DOM when needed. That also solves various problems like rerendering forms and other controls which have focus.\n\nSince everything is rerendered on update, we've decoupled data binding and views and libraries can reuse it in many different ways like [Om](https://github.com/swannodette/om). Even though React implements complicated optimizations, the mental footprint is as small as our Bloop library which is a breathe of fresh air amid other complicated data binding technologies.\n\n## Data Flow\n\n&lt;a id=\"breakpoint-data-flow1\"&gt;&lt;/a&gt;\n\nWe expressed our component's structure in JavaScript instead of trying to mangle it into the DOM. This makes data flow very natural, since we have direct access to the component instance. If you use the DOM directly, it's common to have to wire up the data flow in JavaScript afterwards. A templating engine with automatic bindings helps, but it still creates more complexity than necessary. The days of having one big HTML file are gone; components and their behaviors are intimately dependant and should be encapsulated like so.\n\nAren't you tired of having to query the DOM tree and manually manage the structure to create UIs? Web Components doesn't solve this at all, it just tries to encapsulate the work. **The problem is that building apps *is* building components, so you inevitably are forced back into the manual DOM management to create your app-specific components** (like how you constantly have to create directives in Angular). You also need to jump into JavaScript to configure and wire up any Web Components you used. It's a very messy abstraction, and fools you into desiring a [pure HTML-based declarative way](http://www.polymer-project.org/) to write apps, which is like wanting steak but eating liver.\n\nFrameworks like Ember and Angular help a lot with this. However, templates and controllers are still separated and data binding still leaks into your app (especially in Angular, `$scope.$apply` is the devil). Ember does a better job than most, but you still have to declare data dependencies manually (computed properties) and ultimately accept its way of modelling data. That's not a bad thing but there are things you can't do that we will study later in this article. It simply comes down to the framework vs. library debate.\n\n&lt;a id=\"breakpoint-data-flow2\"&gt;&lt;/a&gt;\n\nIn Bloop, there's a clear and simple flow of data: data is passed down and events flow up. Here is the same example as before, but with multiple components to demonstrate data flow. In all of my examples, you can assume `dom` is set to `Bloop.dom` and that the `App` component is continuously rendered with `requestAnimationFrame` like you saw in the first section.\n\nThere are two components: `Toolbar` which makes a few buttons that change the number, and `App` which is our top-level component that uses `Toolbar`. `App` has state: the current value of the number. It passes this state into `Toolbar`, so that toolbar can decrement and increment the number. But `Toolbar` never touches our app state; it can make a new number, and call the `onChange` handler with the new number, but it can't do anything else. It's up to the `App` component to bind the `onChange` handler to one of its methods which takes the new number and actually modifies the state.\n\nThis introduces another aspect of Bloop: properties. Properties are available as `this.props` and represent the data passed into the component. Components should never mutate their properties. View the full source for this example [here](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-b-increment-decrement-js).\n\n```js\nvar App = Bloop.createClass({\n  getInitialState: function() {\n    return { number: 0 };\n  },\n\n  updateNumber: function(value) {\n    this.state.number = value;\n  },\n  \n  render: function() {\n    return dom.div(\n      dom.span(this.state.number),\n      Toolbar({\n        number: this.state.number,\n        onChange: this.updateNumber\n      })\n    );\n  }\n});\n\nvar Toolbar = Bloop.createClass({\n  render: function() {\n    return dom.div(\n      dom.button({\n        onClick: this.props.onChange.bind(null, this.props.number - 1)\n      }, 'decrement'),\n      dom.button({\n        onClick: this.props.onChange.bind(null, this.props.number + 1)\n      }, 'increment')\n    );\n  }\n});\n```\n\nState flows down the components, and events flow up. Note that while properties should never be changed, state is mutable. Properties can't be changed because they are inherited every time the component is rendered, so any changes will be lost.\n\nThe difference between state and properties can be useful. It makes it clear what state the component owns. It's best to keep most of your components stateless, and isolate state into as few places as possible. This makes it easy to rationalize about your app and how it changes over time. We will explore this more in the next section.\n\nThis example is trivial and so far we've been pretty abstract. You will see more complex examples throughout this post. Communication between components is difficult to do right, and Bloop and React provide you with this simple data flow for handling it, even if it may be limiting in certain cases (you many find yourself adding a lot of trivial methods to `App` to change app state). Check out [this](http://facebook.github.io/react/tips/communicate-between-components.html) and [this](http://facebook.github.io/react/tips/expose-component-functions.html) page from React about it. Near the end of article, we will explore modifications to this approach.\n\n&lt;a id=\"breakpoint-data-flow3\"&gt;&lt;/a&gt;\n\nLet's quickly look at a more complex example. This app has tabs that switch between content, and a settings pane that lets you customize it. [View the code here](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-c-tabbed-app-js). There is a [Tabs](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-c-tabbed-app-js-L65) component that responds to tab changes by calling the `onChange` handler, and we [bind that](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-c-tabbed-app-js-L59) to the `changeTab` method on our top-level `App` component.\n\nAdditionally, there is a [`Settings`](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-c-tabbed-app-js-L87) component that renders the settings form. Whenever a setting changes, all it does is call its `onChange` property, which [we bound](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-c-tabbed-app-js-L45) to the `changeSetting` method on `App`.\n\nFundamentally, this is a declarative way to construct components. The `render` method continuously constructs a new UI based on simple JavaScript objects, binding specific events to component methods.\n\n## Explicit App State\n\nYou're probably already familiar with the pattern of attaching event handlers to components. As described above, Bloop takes this even further though, making it clear that events flow upward, and since everything is in JavaScript it's dead simple to take a JavaScript function and bind it right onto the component. You do this declaratively within `render` when creating the component.\n\nThere's a deeper reason why it's so important to make data flow clear and simple: it encourages you to keep state in as few places as possible and make most of your components stateless. It's easy to create complex data flows in Bloop with many small components, and keep track of what's going on. Additionally, instead of setting state directly on a component instance, Bloop makes it explicitly a separate JavaScript object. Components that do have state can access it with `this.state`. A component that uses state must implement a `getInitialState` method that returns the initial state object.\n\nTearing apart state from the component instance turns out to be really powerful. It fits well with the model that most of our state is held at the top-level, since most of your UI is now described in one simple JavaScript object. This has far-reaching consequences.\n\n1. **It's adaptable.** The state object doesn't have to be a native JavaScript object; it can be anything you return in `getInitialState` (or your own way of passing state around, if you choose). Want to use [persistent data structures](https://github.com/swannodette/mori) instead? Go ahead!\n2. **It's easy to snapshot.** Given a specific state, you can guarantee what the resulting HTML of a component will be. If you simply save the state object somewhere, you can load it up later and render your component exactly like it was when you saved it. An undo system is trivial: just save the state, and restore it (which is especially trivial with persistent data structures).\n3. **It's easy to test and prerender.** Similar to point #2, you can easily test components by rendering them with a specific state to an HTML string and comparing the output. You can even manually fire off event handlers which change state and test the changes. Finally, prerendering on the server is as trivial as it sounds: render the top-level component to a string and serve it up, and when loaded on the client the library will bind all the event handlers to the prerendered DOM.\n\nThe principle to learn is that things like DOM elements are basically native objects, like an open file instance. You don't stick user-land state onto file instances, do you? They are unserializable and slow. Since the DOM doesn't contain our app state, we just have to deal with a simple JavaScript object, declaratively render a structure based on it, and let the library figure out how to reify it into DOM elements.\n\nThe kicker is that the opportunity for great performance falls out of this naturally. React creates a lightweight Virtual DOM every time components are rendered, and diffs them to figure out the smallest amount of real DOM changes needed. The result is astonishing performance since DOM changes are the slowest part. Of course, you don't have to do this; Bloop naively sets `innerHTML` if the contents have changed, but the abstraction is there to allow great optimization.\n\nOk, enough philosophizing, let's get to some examples.\n\nLooking at our app with tabs again, there is a [`Tabs`](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-c-tabbed-app-js-L65) component. This is a completely stateless component, and the top-level `App` component actually handles the tab change and [changes `selectedItem` in the app state](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-c-tabbed-app-js-L21). You might think that `Tabs` *should* handle the state to be reusable, but if you think about it, *something* needs to be hooked up to change the panes when a tab is changed. This makes the dependency on that state explicit and easy to rationalize about.\n\n&lt;a id=\"breakpoint-state1\"&gt;&lt;/a&gt;\n\nIn fact, all of our app state is a single object attached to the `App` component. It's easy to expose this as an editor, which is what you see below. This is the raw state of the app, and is synced both ways. Change it manually in the textarea below (change `bigFonts` to `true`, for example), and click around the app to watch changes come in. \n\n&lt;div id=\"state-settings\"&gt;&lt;textarea&gt;waiting on app state...&lt;/textarea&gt;&lt;/div&gt;\n\nWhen you change it in the textarea above, it is sent to the app and applied by running `app.state = JSON.parse(msg.data)`. It's that easy.\n\nGenerally, your app state will roughly correspond to your UI structure. I think this is what efforts like Web Components are trying to do (hide details about the UI structure), but it doesn't really work if you insist on still using the DOM. This is what you *really* want: a stripped down, bare representation of your app. Your UI structure falls out it of this, not the other way around.\n\n&lt;a id=\"breakpoint-state2\"&gt;&lt;/a&gt;\n\nThe app state is so *simple* and easy to access. Let's implement an undo system and see if we were telling the truth about how easy it is. Let's use a different example app for this: a basic twitter clone ([code here](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-d-twitter-js)).\n\nType some messages into the text input, and press \"enter\" to submit them. Click the star to \"star\" a few of them. Now press the \"undo\" button several times and you will watch your previous actions wash away.\n\nHow is this implemented? Here is the code:\n\n```js\nvar prevStates = [JSON.stringify(appState)];\n\nfunction undo() {\n  while(1) {\n    var state = JSON.parse(prevStates.pop());\n\n    if(!prevStates.length) {\n      // This is the initial app state, so unconditionally apply it\n      // and push it back onto the history so we don't lose it\n      appState.feed = state.feed;\n      prevStates.push(JSON.stringify(state));\n      break;\n    }\n    else if(JSON.stringify(appState.feed) !== JSON.stringify(state.feed)) {\n      // We found a state where the feed has changed, so apply it\n      appState.feed = state.feed;\n      break;\n    }\n  }\n}\n\nfunction render() {\n  app.state = appState;\n  var changed = Bloop.renderComponent(app, document.body);\n  if(changed) {\n    prevStates.push(JSON.stringify(appState));\n  }\n  requestAnimationFrame(render);\n}\n\nrender();\n```\n\nAll we have to do is save the app state when it is changed, and apply a previous state when an undo is requested. There are a few architecture-specific details here: `Bloop` doesn't currently have an event when the state changes, but `Bloop.renderComponent` does return if the rendered output has changed, so we use that to detect when we should save the state. And since we are using simple JavaScript objects, we use `JSON.parse` and `JSON.stringify` to take snapshots of the state. This is very simplistic, but you could implement more powerful ways to track changes like using persistent data structures.\n\nNote that we only undo changes to the feed. In `undo`, we walk back through the history and find an app state where the `feed` structure has changed, skipping over any other state changes. It's up to you to determine what you want to track and undo.\n\nIf you're undoing UI that is backed by a data store, you also need to perform the undo in the backend. You can use a versioned data store, which makes it just as trivial. Or you can diff the app state and generate actions to perform the undo. This is something that needs to be explored more, and is the reverse of usual undo methods, where you manually undo changes in the database and then re-fetch data and refresh the whole UI. That might be just fine for your app, but it gets tedious to hand-code undo code paths for every single model. This is far more powerful because it's automatically applicable to any component.\n\nForcing your data through the backend data store to allow undo is also limiting. What if you want to not actually persist the action for 30 seconds, and give the user the chance to undo before it even hits the backend? Our architecture makes it trivial to go ahead and update the UI as if it has persisted in the data store, but let the user undo the action before it actually hits the backend. We get all of this for free.\n\n[This pixel editor named Goya](http://jackschaedler.github.io/goya/), written in [Om](https://github.com/swannodette/om/) which is built on top of React, leverages this technique for tracking history, and allowing you to travel through changes. [Here's all the code](https://github.com/jackschaedler/goya/blob/master/src/cljs/goya/timemachine.cljs) it took to implement undo/redo. When it's independent of your data structure (as a good abstraction should be!) it's trivial!\n\nOne last example of explicit app state: prerendering and testing. Instead of using `Bloop.renderComponent`, you can use `Bloop.renderComponentToString` to render a component with properties to a string of HTML. This makes it trivial to test, just render the component and compare the output. This is the toolbar from the example on the right (if you [open the example](http://jlongster.com/s/bloop/app3/) in a tab, you can run this code from the console):\n\n```js\nBloop.renderComponentToString(Toolbar({ username: 'foo' }))\n\n// Output:\n// \"&lt;div class=\"toolbar\"&gt;&lt;em&gt;Logged in as foo&lt;/em&gt;&lt;button&gt;settings&lt;/button&gt;&lt;button&gt;undo&lt;/button&gt;&lt;/div&gt;\"\n```\n\nYou might not want to compare strings directly, but you could do specific tests to make sure that changes in state relate to changes in structure.\n\nIf you want to prerender your app, you could simply render the top-level `App` component with the initial app state on the server and send it to the client. The library can then simply bind event listeners to the already rendered DOM (Bloop does not support this, but React does). It's literally just a few lines of code.\n\nBloop itself is extremely simplistic, but we already get most of this for free. React makes it easy to use these techniques for real apps because it handles all the hard stuff, too. There's a lot of win here, and a lot of opportunity for interesting advancements.\n\n\n## Game Loop\n\nSo far, we've said that the structure of a component created within the `render` method is *declarative*. This is because you generate the structure based off of the app state, nothing else. As the app state changes, so does your structure. However, it may not look like traditionally declarative code, since any JavaScript can be run:\n\n```js\nBloop.createClass({\n  render: function() {\n    var items = this.props.items.filter(function(item) {\n      return item.isVisible;\n    });\n    \n    return items.map(function(item) {\n      return dom.div(item.name);\n    });\n  }\n})\n```\n\nThere is a declarative current running underneath this code. But we can look at it in a different light: almost as if we're operating in an [immediate rendering](http://en.wikipedia.org/wiki/Direct_mode) mode, as if the `dom.div` and such functions painted the element instantly. In fact, since we're using `requestAnimationFrame` to repaint the UI, this is extremely similar to how game developers render UI in games.\n\nGame developers discovered [immediate-mode graphical user interfaces](https://mollyrocket.com/861) years ago (watch that video, it's awesome). Their power lies in the fact that you just run normal JavaScript to paint your UI: conditional elements are literally expressed as `if(shown) { renderItem(); }`, and that data is always synced with the UI because the UI is always redrawn.\n\nThe web traditionally operates in [retained mode](http://en.wikipedia.org/wiki/Retained_mode), where the DOM exists as an in-memory representation of the current UI, and you poke it to make changes. Since we can't throw away the current web, our library still creates DOM elements using our declarative forms. So we're basically operating in an immediate mode on top of a retained mode, and I'm starting to think that it actually gets us the best of both worlds. React provides \"lifecycle\" methods which trigger at various stages within the retained DOM, which gives you an escape hatch when you need to handle things like focus. Even if it might be better for React if there was a lower-level rendering API, just using the DOM works pretty well.\n\nIf our library can make edits to the retained DOM fast enough, we can actually treat our `render` methods as if they were in immediate mode. That means we can implement performance-sensitive things like 60 FPS animations, or a UI that changes when scrolling. You may think it's taboo not to use CSS for animations, but with `requestAnimationFrame` and other advancements, people are finding out that you can actually use JavaScript for better and even more performant animations, as seen with [Velocity.js](http://julian.com/research/velocity/).\n\nReact, with its Virtual DOM, is fast enough to implement animations that depend on user input, like scrolling or cursor position. Bloop is dumb and uses `innerHTML` so it's not nearly as good, but on desktop it's at least good enough to show an example.\n\nA wonderful thing about immediate mode is that it's easy to do things like [occlusion culling](http://en.wikipedia.org/wiki/Hidden_surface_determination). Another corollary to graphics engines, occlusion culling is an algorithm to optimize rendering by figuring out which elements are actually visible, and only rendering them. Imagine you have a list of 5000 items. If you create a big `&lt;ul&gt;` with all of them, the DOM will grow large, take up lots of memory, and scrolling will be degraded (*especially* on mobile). If you know only 25 are on the screen at once, why do we need to create 5000 DOM elements?\n\n&lt;a id=\"breakpoint-game-loop1\"&gt;&lt;/a&gt;\n\nYou should only need 25 DOM elements at one time, and fill them out with the 25 elements that pass the occlusion test. I made this component in just a few minutes to make this work (view the full code [here](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-e-optimized-list-js)):\n\n```js\nvar App = Bloop.createClass({\n  getInitialState: function() {\n    return { pageY: 0,\n             pageHeight: window.innerHeight };\n  },\n\n  componentDidRender: function() {\n    var numItems = this.props.items.length;\n    document.querySelector('.list').style.height = numItems * 31 + 'px';\n    var ul = document.querySelector('ul');\n    ul.style.top = this.state.pageY + 'px';\n  },\n\n  render: function() {\n    var pageY = this.state.pageY;\n    var begin = pageY / 31 | 0;\n    // Add 2 so that the top and bottom of the page are filled with\n    // next/prev item, not just whitespace if item not in full view\n    var end = begin + (this.state.pageHeight / 31 | 0 + 2);\n\n    var offset = pageY % 31;\n    \n    return dom.div(\n      { className: 'list',\n        style: 'position: relative; top: ' + (-offset) + 'px' },\n      dom.ul(\n        this.props.items.slice(begin, end).map(function(item) {\n          return dom.li(null, item.title);\n        })\n      )\n    );\n  }\n});\n```\n\nThis assumes each list item has a height of `31px`, and can calculate which set of items are visible given the page scroll position and window height. The `render` method only returns a fixed size of `&lt;li&gt;` elements always (probably ~25), no matter how large the list is. The `&lt;ul&gt;` is shifted as the user scrolls so it actually stays in one place, but the outer container is given the full height of the list so that we still have an accurate scrollbar.\n\nGo ahead, right-click and inspect one of the list elements in your browser's developer tools. Look around and you'll only see a modest number of `&lt;li&gt;` elements.\n\nHere's the code for initializing and rendering this component:\n\n```js\n// application code\n\nvar items = [];\nfor(var i=0; i&lt;5000; i++) {\n  items.push({\n    title: 'Foo Bar ' + i\n  });\n}\n\nvar app = App({ items: items });\n\nwindow.addEventListener('scroll', function(e) {\n  app.state.pageY = Math.max(e.pageY, 0);\n  app.state.pageHeight = window.innerHeight;\n});\n\n// render\n\nfunction render() {\n  Bloop.renderComponent(app, document.body);\n  requestAnimationFrame(render);\n}\n\nrender();\n```\n\nWhen the `scroll` event is fired, we simply update `pageY` and `pageHeight` and the new DOM elements are filled with the right data, giving the illusion that the user is scrolling down a large list. This basic implementation isn't perfect, but it certainly could be with some better edge case handling.\n\nThis is all just with my stupid [Bloop](https://gist.github.com/jlongster/11192270) library, just imagine what you could do with React's optimizations.\n\n&lt;a id=\"breakpoint-game-loop2\"&gt;&lt;/a&gt;\n\nContrast this with what it would take to implement with Web Components. You would have to manually manage all of those DOM nodes yourself, and take special care to remove ones outside of the viewport, or even better reuse them and reposition them. Retained mode is a sucky way of doing UIs, and I think we'd all be better off if we switched to thinking in immediate mode.\n\n## Additional Abstractions\n\n### Cortex\n\nWe went over how data flows in Bloop and React: data is passed down and events are triggered up through event handlers. This is a good way for components to talk to each other, but it has drawbacks. Sometimes it's annoying to create many trivial event handlers, and you also *want* to be able to wrap state management into components instead of it all being top-level.\n\nThere are many ways to improve this, and React actually encourages its community to build interesting abstractions on top of React. [Cortex](https://github.com/mquan/cortex/) is one such enhancement of handling state.\n\nCortex is a way to have one single data structure for app state, but have the ability to take pieces of it and hand it off to child components. Child components have the ability to *change* state themselves, and we get update notifications. It's basically a type of \"observable\", but the difference is we don't care what has changed. When we get an update notification, we just trigger a rerender of the whole app.\n\nHere's what using Cortex looks like:\n\n```js\nvar data = { settings: { username: \"James \"},\n             number: 0 };\n\nvar cortex = new Cortex(data, function() {\n  // Called whenever an update happened\n  Bloop.renderComponent(app, document.body);\n});\n```\n\nIn my component, if I had a `Settings` component I could pass it down like so:\n\n```js\nvar App = Bloop.createClass({\n  render: function() {\n    return dom.div(\n      MainContent(),\n      Settings({ state: this.state.settings })\n    );\n  }\n});\n```\n\nAnd the `Settings` component could update it like so:\n\n```js\nvar Settings = Bloop.createClass({\n  updateUsername: function(username) {\n    this.state.username.set(username);\n  },\n  \n  render: function() {\n    // ...\n  }\n});\n```\n\nThe callback we passed to `Cortex` would be called and the app would be rerendered. Now we can do more sophisticated state management, letting components manage the state themselves but still having full access to the state from the top-level through our normal `data` object. It's like proper Object-Oriented Programming!\n\nIndeed, if you are familiar with [functional lenses](https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/basic-lensing) this sounds all too familiar to you. Unfortunately, this is still a mutable data structure, but it still solves the encapsulation problem.\n\nThe above code is Bloop-specific. In React, you would need to access the cortex object in `props` in components that get state passed down. Bloop allows you to specify a `state` property when creating the component, and it is used as the component's initial state.\n\n&lt;a id=\"breakpoint-cortex1\"&gt;&lt;/a&gt;\n\nHere is the full increment/decrement example using Cortex (or as a [gist](https://gist.github.com/jlongster/3f32b2c7dce588f24c92#file-f-cortex-js)):\n\n```js\nvar dom = Bloop.dom;\n\n// components\n\nvar App = Bloop.createClass({\n  render: function() {\n    return dom.div(\n      dom.span(this.state.number.val()),\n      Toolbar({\n        number: this.state.number\n      })\n    );\n  }\n});\n\nvar Toolbar = Bloop.createClass({\n  updateNumber: function(value) {\n    this.props.number.set(value);\n  },\n  \n  render: function() {\n    return dom.div(\n      dom.button({\n        onClick: this.updateNumber.bind(null, this.props.number.val() - 1)\n      }, 'decrement'),\n      dom.button({\n        onClick: this.updateNumber.bind(null, this.props.number.val() + 1)\n      }, 'increment')\n    );\n  }\n});\n\nvar data = { number: 0 };\n\nvar cortex = new Cortex(data, function() {\n  // Called whenever an update happened\n  Bloop.renderComponent(app, document.body);\n});\n\n// render\n\nvar app = App({ state: cortex });\nBloop.renderComponent(app, document.body);\n```\n\n### Bacon.js\n\nIf functional reactive programming (FRP) is your thing, I'm sure you've heard of [bacon.js](https://github.com/baconjs/bacon.js/tree/master). Since Bloop doesn't care where your data comes from, it's trivial to use FRP to construct data flows and update the UI whenever something comes down the stream. [This post](http://joshbassett.info/2014/reactive-uis-with-react-and-bacon/) describes how to do just that with bacon.js.\n\n### Addon: Immutability Helper\n\nReact actually comes with an addon that lets you update data structures persistently, the [immutability helper](http://facebook.github.io/react/docs/update.html). The neat thing is that you can still use native JavaScript data structures, but create new objects when performing updates instead of mutating them directly.\n\nIt's a little unwieldy to use, however, but with some [macro magic](http://sweetjs.org/) it could be quite handy.\n\n### Om\n\n[Om](https://github.com/swannodette/om/) is a much more sophisticated abstraction on top of React. It is a ClojureScript interface to React that [introduces](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/) a different way of defining components and managing state. Since ClojureScript uses persistent data structures natively, app state is immutable and persistent. This immutability makes it trivial to check what has changed, since you just have to compare pointers.\n\nOm uses `requestAnimationFrame` to &lt;del&gt;render the app continuously&lt;/del&gt; batch rendering (all requests for rerendering happen just once on the next animation frame). If something has changed, it's very quick to detect the components that have changed with a few more pointer checks and rerender those components.\n\nImmutability turns out to be an incredible companion to React, making not only app state explicit but also changes over time. Keeping a history involves only keeping pointers to previous app states.\n\nI would love to dive into this more, but that is for a future post.\n\n### Mori\n\n[Mori](https://github.com/swannodette/mori) is a library for persistent data structures for JavaScript. These are same data structures used by ClojureScript. If you want a lot of the same benefits that Om takes advantage of, like optimized rendering and easy history and undo, you can use this library to manage app state as a persistent data structure.\n\nI haven't seen too many persistent JavaScript react apps yet, but there is [this post](http://tech.kinja.com/immutable-react-1495205675) about using a [different](https://github.com/hughfdjackson/immutable) persistent data structure library for building apps.\n\n&lt;a id=\"breakpoint-finale\"&gt;&lt;/a&gt;\n\n## Finale\n\nWe've shown how React chooses a level of abstraction that is powerful, and also adaptive. We haven't explored the details of React's optimizations with the virtual DOM, but you can find more about that in the [docs](http://facebook.github.io/react/docs/getting-started.html) and around the web. I wanted to focus on the abstract idea itself, and show how well it works even with my stupidly simple Bloop library.\n\nBloop follows most of React's APIs and conventions, with the following differences: in React, the properties object is required when creating DOM elements, so you have to pass `null` if there aren't any (`dom.div(null, 'text')`). There also is no `componentDidRender` in React, but there is `componentDidUpdate`.\n\nThis post assumes Web Components as a way to build applications; some people look at Web Components as a low-level way to share custom components. Even so, everything is stuck in a global namespace and you miss out on all the goodness of modules. Also, it's a hard sell when something like React can't even use it, and it's hard to load in components from a completely different system, especially when you want to take advantage of what you already have.\n\nThere's no doubt that you will need more than this for building apps: we haven't mentioned routing, data stores, controllers, and all that stuff. I like the ability to choose which libraries to use and see how they are all pieced together. See React's post about the [flux](http://facebook.github.io/react/blog/2014/05/06/flux.html) architecture, a [router](https://github.com/andreypopp/react-router-component), and [more](https://medium.com/react-tutorials/c00be0cf1592).\n\nIt's no coincidence that immutability and persistence was repeatedly referenced throughout this post. Using persistent data structures with this architecture really does allow for powerful features. However, even with simple mutable JavaScript objects, React brings a powerful UI and component system to the table.\n\nRead more:\n\n* [Bloop](https://gist.github.com/jlongster/11192270)\n* [Source code](https://gist.github.com/jlongster/3f32b2c7dce588f24c92) for all the demos\n* React [docs](http://facebook.github.io/react/)\n* React provides [JSX](http://facebook.github.io/react/docs/jsx-in-depth.html), an extension to JavaScript, which allows you to embed HTML directly in JavaScript. This makes it look like you are writing HTML, but all it does it transform to the native `dom.*` calls. I prefer not to use it, but it's helpful if you are working with designers.\n* [Om](https://github.com/swannodette/om/) is a ClojureScript interface to React\n* [Mori](http://swannodette.github.io/mori/) is a library of persistent data structures for JavaScript\n* [Cortex](https://github.com/mquan/cortex/) provides a way to centrally manage data\n* [Mercury](https://github.com/Raynos/mercury) is an attempt to rebuild something like React, separating functionality into lots of modules like [virtual-dom](https://github.com/Matt-Esch/virtual-dom). It features immutable-by-default state and virtual DOM, see more comparison [here](https://github.com/Raynos/mercury#mercury-vs-react).\n* [Mithril](http://lhorie.github.io/mithril/) is another framework that has similar ideas, and the author has commented and ported my examples [here](http://lhorie.github.io/mithril-blog/an-exercise-in-awesomeness.html).\n\n&lt;script src=\"http://jlongster.com/s/jlongster.com-util/jquery-2.1.0.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"http://jlongster.com/s/jlongster.com-util/underscore-min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"http://jlongster.com/s/shift/build/lib/react.dev.js\"&gt;&lt;/script&gt;\n&lt;script src=\"http://jlongster.com/s/shift/build/shift.js\"&gt;&lt;/script&gt;\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://jlongster.com/s/shift/build/shift.css\" /&gt;","date":20140513,"readnext":"Writing-Your-First-Sweet.js-Macro","abstract":"I've been studying frameworks and libraries like Ember, Angular, and React the past several months, and given Web Components a lot of thought. I found React to be the most enlightening, and I'll explain why.","shorturl":"Removing-User-Interface-Complexity,-or-Why-React-is-Awesome","headerimgfull":false}}},"user":{"admin":false},"config":{"url":"http://jlongster.com"}}</script>
    <script src="/output/bundle.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-9014321-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
